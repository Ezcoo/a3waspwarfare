//todo: Kerberos Tracker -> perma track main infos with clients UID (teamkills, kills, hq killed (ff/no ff)).

CTI_SE_FNC_AddScore = compileFinal preprocessFileLineNumbers "Server\Functions\Server_AddScore.sqf";
CTI_SE_FNC_AttemptDefenseDelegation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_AttemptDefenseDelegation.sqf";
CTI_SE_FNC_AttemptTownDelegation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_AttemptTownDelegation.sqf";
CTI_SE_FNC_AttemptTownDefenseDelegation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_AttemptTownDefenseDelegation.sqf";
CTI_SE_FNC_BuildStructure = compileFinal preprocessFileLineNumbers "Server\Functions\Server_BuildStructure.sqf";
CTI_SE_FNC_BuildDefense = compileFinal preprocessFileLineNumbers "Server\Functions\Server_BuildDefense.sqf";
CTI_SE_FNC_CanCaptureTerritorialTown = compileFinal preprocessFileLineNumbers "Server\Functions\Server_CanCaptureTerritorialTown.sqf";
CTI_SE_FNC_CreateTownDefenses = compileFinal preprocessFileLineNumbers "Server\Functions\Server_CreateTownDefenses.sqf";
CTI_SE_FNC_CreateStaticTownDefenses = compileFinal preprocessFileLineNumbers "Server\Functions\Server_CreateStaticTownDefenses.sqf";
CTI_SE_FNC_HandleAIPurchase = compileFinal preprocessFileLineNumbers "Server\Functions\Server_HandleAIPurchase.sqf";
CTI_SE_FNC_HandleEmptyVehicle = compileFinal preprocessFileLineNumbers "Server\Functions\Server_HandleEmptyVehicle.sqf";
CTI_SE_FNC_HandleStaticDefenses = compileFinal preprocessFileLineNumbers "Server\Functions\Server_HandleStaticDefenses.sqf";
CTI_SE_FNC_HandleStructureConstruction = compileFinal preprocessFileLineNumbers "Server\Functions\Server_HandleStructureConstruction.sqf";
CTI_SE_FNC_InitializeGroup = compileFinal preprocessFileLineNumbers "Server\Functions\Server_InitializeGroup.sqf";
CTI_SE_FNC_InitializeStructure = compileFinal preprocessFileLineNumbers "Server\Functions\Server_InitializeStructure.sqf";
CTI_SE_FNC_NoobLogger = compileFinal preprocessFileLineNumbers "Server\Functions\Server_NoobLogger.sqf";
CTI_SE_FNC_NoobLoggerEnd = compileFinal preprocessFileLineNumbers "Server\Functions\Server_NoobLoggerEnd.sqf";
CTI_SE_FNC_OnBuildingDestroyed = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnBuildingDestroyed.sqf";
CTI_SE_FNC_OnBuildingHandleDamage = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnBuildingHandleDamage.sqf";
CTI_SE_FNC_OnBuildingHandleVirtualDamage = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnBuildingHandleVirtualDamage.sqf";
CTI_SE_FNC_OnBuildingHit = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnBuildingHit.sqf";
CTI_SE_FNC_OnDefenseHit = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnDefenseHit.sqf";
CTI_SE_FNC_OnExplosion = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnExplosion.sqf";
CTI_SE_FNC_OnArtilleryFired = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnArtilleryFired.sqf";
CTI_SE_FNC_OnCampCaptured = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnCampCaptured.sqf";
CTI_SE_FNC_OnClientPurchase = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnClientPurchase.sqf";
CTI_SE_FNC_OnClientPurchaseCancelled = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnClientPurchaseCancelled.sqf";
CTI_SE_FNC_OnClientPurchaseComplete = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnClientPurchaseComplete.sqf";
CTI_SE_FNC_OnOnDefenseHandleDamage = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnDefenseHandleDamage.sqf";
CTI_SE_FNC_OnDefenseHandleVirtualDamage = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnDefenseHandleVirtualDamage.sqf";
CTI_SE_FNC_OnFOBHandleVirtualDamage = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnFOBHandleVirtualDamage.sqf";
CTI_SE_FNC_OnDefenseDestroyed = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnDefenseDestroyed.sqf";
CTI_SE_FNC_OnFOBDestroyed = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnFOBDestroyed.sqf";
CTI_SE_FNC_OnHQDestroyed = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnHQDestroyed.sqf";
CTI_SE_FNC_OnTownActivation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnTownActivation.sqf";
CTI_SE_FNC_OnTownCaptured = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnTownCaptured.sqf";
CTI_SE_FNC_OnTownDeactivation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_OnTownDeactivation.sqf";
CTI_SE_FNC_RemoveTownDefenses = compileFinal preprocessFileLineNumbers "Server\Functions\Server_RemoveTownDefenses.sqf";
CTI_SE_FNC_RemoveStaticTownDefenses = compileFinal preprocessFileLineNumbers "Server\Functions\Server_RemoveStaticTownDefenses.sqf";
CTI_SE_FNC_RepairHQ = compileFinal preprocessFileLineNumbers "Server\Functions\Server_RepairHQ.sqf";
CTI_SE_FNC_SpawnTownOccupation = compileFinal preprocessFileLineNumbers "Server\Functions\Server_SpawnTownOccupation.sqf";
CTI_SE_FNC_SpawnTownResistance = compileFinal preprocessFileLineNumbers "Server\Functions\Server_SpawnTownResistance.sqf";
CTI_SE_FNC_StartFactoryQueue = compileFinal preprocessFileLineNumbers "Server\Functions\Server_StartFactoryQueue.sqf";
CTI_SE_FNC_StartUpgrade = compileFinal preprocessFileLineNumbers "Server\Functions\Server_StartUpgrade.sqf";
CTI_SE_FNC_ToggleHQ = compileFinal preprocessFileLineNumbers "Server\Functions\Server_ToggleHQ.sqf";
CTI_SE_FNC_TrashObject = compileFinal preprocessFileLineNumbers "Server\Functions\Server_TrashObject.sqf";
CTI_SE_FNC_UpdateBaseAreas = compileFinal preprocessFileLineNumbers "Server\Functions\Server_UpdateBaseAreas.sqf";
CTI_SE_FNC_VoteForCommander = compileFinal preprocessFileLineNumbers "Server\Functions\Server_VoteForCommander.sqf";
CTI_SE_FNC_DeployFOB = compileFinal preprocessFileLineNumbers "Server\Functions\Server_DeployFOB.sqf";
CTI_SE_DatabaseLoop = compileFinal preprocessFileLineNumbers "Server\Functions\Database\DatabaseUpdateLoop.sqf";
CTI_SE_FNC_DatabaseUpdate = compileFinal preprocessFileLineNumbers "Server\Functions\Database\Server_DB_UpdateDatabase.sqf";
CTI_SE_FNC_ExecCommand = compileFinal preprocessFileLineNumbers "Server\Functions\Database\Server_DB_ExecCommand.sqf";
CTI_SE_FNC_DB_ReadDatabase = compileFinal preprocessFileLineNumbers "Server\Functions\Database\Server_DB_ReadDatabase.sqf";
CTI_SE_FNC_FPS_DatabaseInformationRequest = compileFinal preprocessFileLineNumbers "Server\Functions\Database\Server_DB_getServerFPS.sqf";
funcCalcAlignPosDir = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fCalcAlignPosDir.sqf";
funcVectorAdd = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fVectorAdd.sqf";
funcVectorCross = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fVectorCross.sqf";
funcVectorDot = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fVectorDot.sqf";
funcVectorScale = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fVectorScale.sqf";
funcVectorSub = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\fVectorSub.sqf";

call compile preprocessFileLineNumbers "Server\Init\Init_PublicVariables.sqf";
call compile preprocessFileLineNumbers "Server\Functions\FSM\Functions_FSM_RepairTruck.sqf";
call compile preprocessFileLineNumbers "Server\Functions\FSM\Functions_FSM_UpdateAI.sqf";
call compile preprocessFileLineNumbers "Server\Functions\FSM\Functions_FSM_UpdateCommander.sqf";

execVM "Server\Init\Init_Prison.sqf";

//--- Get the starting locations.
_startup_locations = [];
_lastLocation = 0;
for '_i' from 0 to 30 do {
	_location = getMarkerPos format ["cti-spawn%1", _i];
	if (_location select 0 isEqualTo 0 && _location select 1 isEqualTo 0) exitWith {};
	_startup_locations pushBack _location;
	_lastLocation = _i;
};

//--- Place both sides.
_range = missionNamespace getVariable "CTI_BASE_STARTUP_PLACEMENT";
_westLocation = getMarkerPos "cti-spawn0";
_eastLocation = getMarkerPos "cti-spawn0";
_acceptablePairs = []; // This will be our list of acceptable startup location pairings.

while {_range >= 3000} do {
	for '_i' from 0 to _lastLocation do {
		for '_j' from 0 to _lastLocation do {
			_location1 = getMarkerPos format ["cti-spawn%1", _i];
			_location2 = getMarkerPos format ["cti-spawn%1", _j];
			if (_location1 distance _location2 > _range) then {
				_acceptablePairs pushback [_location1, _location2];
			};
		};
	};
	if (count _acceptablePairs > 0) exitWith {}; // If valid locations are in the list, we're done
	_range = _range - 2000;	// Reduce our minimum range and try again if we found nothing
	//systemChat format ["Base Startup Placement Range reduced to: %1", _range];
};
if (count _acceptablePairs > 0) then {
	_locationPair = selectRandom _acceptablePairs; // Pick a pair from our list
	_eastLocation = _locationPair select 0;
	_westLocation = _locationPair select 1;
} else { 
	_westLocation = getMarkerPos "cti-spawn0"; //N
	_eastLocation = getMarkerPos "cti-spawn1"; //S
}; 
CTI_WEST_START = _westLocation;
CTI_EAST_START = _eastLocation;


{
	_side     = _x select 0;
	_logic    = _x select 1;
	_startPos = _x select 2;
	_sideID   = _side call CTI_CO_FNC_GetSideID;
	
	_position = [_startPos, 1, 35, 5, "vehicles", ["Man","Car","Motorcycle","Tank","Ship","Air","StaticWeapon"], 5] call CTI_CO_FNC_GetSafePosition;
	
	_hq = [missionNamespace getVariable format["CTI_%1_HQ", _side], _position, 0, _side, true, false, false, "", objNull, false] call CTI_CO_FNC_CreateVehicle;
	
	_hq setVariable ["cti_ai_prohib", true]; //--- HQ may not be used by AI as a commandable vehicle
	_hq setVariable ["cti_mhq_fuel", true]; //--- HQ fuel variable
	_hq addEventHandler ["killed", format["[_this select 0, _this select 1, %1] spawn CTI_SE_FNC_OnHQDestroyed", _sideID]];
	if (CTI_BASE_NOOBPROTECTION isEqualTo 1) then {
		_hq addEventHandler ["handleDamage", format["[_this select 2, _this select 3, %1] call CTI_CO_FNC_OnHQHandleDamage", _sideID]]; //--- You want that on public
	};
	
	//--- Generic per-logic variables
	_logic setVariable ["cti_hq", _hq, true];
	_logic setVariable ["cti_hq_deployed", false, true];
	_logic setVariable ["cti_structures_wip", [], true];
	_logic setVariable ["cti_structures", [], true];
	_logic setVariable ["cti_structures_areas", [], true];
	_logic setVariable ["cti_structures_lasthit", -600];
	_logic setVariable ["cti_workers", [], true];
	_logic setVariable ["cti_commander_team", grpNull, true];
	_logic setVariable ["cti_ai_commander", false];
	_logic setVariable ["cti_commander_funds", missionNamespace getVariable format ["CTI_ECONOMY_STARTUP_FUNDS_%1_COMMANDER", _side], true];
	_logic setVariable ["cti_pool_award", missionNamespace getVariable format ["CTI_ECONOMY_POOL_AWARD_PERCENTAGE_%1", _side], true];
	_logic setVariable ["cti_pool_resources", missionNamespace getVariable format ["CTI_ECONOMY_POOL_RESOURCES_PERCENTAGE_%1", _side], true];
	_logic setVariable ["cti_salvagers", [], true];
	_logic setVariable ["cti_spotted_units", []];
	_logic setVariable ["cti_spotted_structures", []];
	_logic setVariable ["cti_supply", missionNamespace getVariable format ["CTI_ECONOMY_STARTUP_SUPPLY_%1", _side], true];
	_logic setVariable ["cti_player_ai_skill", 40, true];
	
	_upgrades = [];
	for '_i' from 1 to count(missionNamespace getVariable format["CTI_%1_UPGRADES_LEVELS", _side]) do { _upgrades pushBack 0 };
	// for '_i' from 1 to count(missionNamespace getVariable format["CTI_%1_UPGRADES_LEVELS", _side]) do { _upgrades pushBack 1 };
	_logic setVariable ["cti_upgrades", _upgrades, true];
	_logic setVariable ["cti_upgrade", -1, true];
	_logic setVariable ["cti_upgrade_lt", -1, true];
	
	//--- Create the defensive teams if needed
	if (CTI_BASE_DEFENSES_AUTO_MODE > 0) then {
		_defense_team = createGroup _side;
		_defense_team setGroupID ["Defense Team"];
		_defense_team setBehaviour "AWARE";
		_defense_team setCombatMode "RED";
		_defense_team enableAttack true;
		_logic setVariable ["cti_defensive_team", _defense_team, true];
	};
	
	//--- Add FOB if needed
	if (CTI_BASE_FOB_MAX > 0) then {_logic setVariable ["cti_fobs", [], true]};
	//--- Add LARGE FOB if needed
	if (CTI_BASE_LARGE_FOB_MAX > 0) then {_logic setVariable ["cti_large_fobs", [], true]};
	
	//--- Startup vehicles
	{
		_model = _x select 0;
		_equipment = _x select 1;
		
		_position = [getPos _hq, 30, 60, 10, "vehicles", ["Man","Car","Motorcycle","Tank","Ship","Air","StaticWeapon"], 8] call CTI_CO_FNC_GetSafePosition;
		
		_vehicle = [_model, _position, [_hq, _position] call CTI_CO_FNC_GetDirTo, _side, false, true, true] call CTI_CO_FNC_CreateVehicle;
		[_vehicle] spawn CTI_SE_FNC_HandleEmptyVehicle;
		if (count _equipment > 0) then {[_vehicle, _equipment] call CTI_CO_FNC_EquipVehicleCargoSpace};
		if ((missionNamespace getVariable [format ["%1", _model],["","","","","","","",""]]) select CTI_UNIT_SCRIPT != "") then {[_vehicle, _side, ((missionNamespace getVariable [format ["%1", _model],["","","","","","","",""]]) select CTI_UNIT_SCRIPT)] call CTI_CO_FNC_InitializeCustomVehicle;};
	} forEach (missionNamespace getVariable format["CTI_%1_Vehicles_Startup", _side]);
	
	//--- Handle the Team
	_teams = [];
	{
		if !(isNil '_x') then {
			if (_x isKindOf "Man") then {
				_group = group _x;
				_teams pushBack _group;
				[_group, _side] call CTI_SE_FNC_InitializeGroup;
				
				[leader _group, missionNamespace getVariable format ["CTI_AI_%1_DEFAULT_GEAR", _side]] call CTI_CO_FNC_EquipUnit;
				
				if !(isPlayer leader _group) then {
					(leader _group) enableSimulationGlobal false;
					(leader _group) hideObjectGlobal true;
					(leader _group) disableAI "FSM";
				};
				
				//--- ZEUS Curator Editable
				if !(isNil "ADMIN_ZEUS") then {ADMIN_ZEUS addCuratorEditableObjects [[leader _group], true]};
			};
		};
	} forEach (synchronizedObjects _logic);
	
	//--- Disable Thermals and Statics
	if ( (missionNamespace getVariable 'CTI_SM_NV_THER_VEH') > 0) then {
		0 spawn {
			while {!CTI_GameOver} do {
				{
					if ((missionNamespace getVariable 'CTI_SM_NV_THER_VEH')== 1) then {_x disableNVGEquipment true;};
					if ((missionNamespace getVariable 'CTI_SM_NV_THER_VEH')== 2) then {_x disableTIEquipment true;};
					if ((missionNamespace getVariable 'CTI_SM_NV_THER_VEH')== 3) then {_x disableTIEquipment true;_x disableNVGEquipment true;};
				}
				forEach vehicles;
				sleep 10;
			};
		};
	};
	_logic setVariable ["cti_teams", _teams, true];
} forEach [[west, CTI_WEST, _westLocation], [east, CTI_EAST, _eastLocation]];

//--- Towns init thread + Vote
0 spawn {
	waitUntil {!isNil 'CTI_InitTowns'};
	
	//--- Initialize the game SQF after that the towns are initialized
	ExecVM "Server\FSM\update_ai_defensive.sqf";

	//ExecVM "Server\FSM\update_garbage_collector.sqf";

	ExecVM  "Server\FSM\update_resources.sqf";
	ExecVM "Server\FSM\update_victory.sqf";
	
	waitUntil {time > 0};
	
	{_x Spawn CTI_SE_FNC_VoteForCommander} forEach CTI_PLAYABLE_SIDES;
};

// Date init
_it=0;
_possible_it_off=[0,0,0,0,0,0,6,6,6,12,12,12,18];
if ((missionNamespace getVariable "CTI_WEATHER_INITIAL") < 18) then {
	_it=(missionNamespace getVariable "CTI_WEATHER_INITIAL");
} else {
	_it= selectRandom _possible_it_off;
};
//Default Time Starts at 0600am
skipTime _it;


// dynamic weather
execVM "Server\Functions\Server_Weather_Hook.sqf";	

// Create HQs for each side
{
	private _HQ = _x call bis_fnc_moduleHQ;
	if (isNull _HQ) then {
		_HQ = (createGroup _x) createUnit ["ModuleHQ_F",[10,10,10],[],0,"none"];
		_HQ setGroupIdGlobal ["CROSSROAD"];
	};
	_speakers = missionNamespace getVariable format["CTI_%1_Speakers", _x];
	_speaker = selectRandom _speakers;
	_HQ setPitch 1;
	[_HQ, _speaker] remoteExecCall ["setSpeaker", 0, true];
	[_HQ, 1] remoteExecCall ["setPitch", 0, true];
	_HQ kbAddTopic [CTI_HQTopicSideVanilla, "Common\Config\Common\Radios\VanillaRadio.bikb"];
	
	_speakers = missionNamespace getVariable [format["CTI_%1_Speakers_CTI", _x], missionNamespace getVariable format["CTI_%1_Speakers", _x]];
	_speaker = selectRandom _speakers;
	_hqLow = (createGroup _x) createUnit ["Logic", [10,10,1000], [], 0, "NONE"];
	_hqLow setGroupIdGlobal ["COMMAND"];
	[_hqLow, _speaker] remoteExecCall ["setSpeaker", 0, true];
	missionNamespace setVariable [format["CTI_%1_HQ_Announcer", _x], _hqLow, true];
	_hqLow kbAddTopic [CTI_HQTopicSide,"Common\Config\Common\Radios\CUPRadio.bikb","",{call compile preprocessFileLineNumbers "Common\Config\Common\Radios\kbRadio.sqf"}];
	[_hqLow, 1] remoteExecCall ["setPitch", 0, true];
	
} forEach [west, east, resistance];



// Fast time compression
0 spawn {
	_day_ratio = 14/CTI_WEATHER_FAST;
	_night_ratio = 10/CTI_WEATHER_FAST_NIGHT;
	while {!CTI_Gameover} do {
		if (daytime > 4 && daytime < 18.5 ) then {
			if (timeMultiplier != _day_ratio) then  {setTimeMultiplier _day_ratio ; };
		} else {
			if (timeMultiplier !=  _night_ratio) then {setTimeMultiplier _night_ratio ; };
		};
		sleep 120;
	};
};

if (CTI_DATABASE_TRACKING) then 
{
	//--- Check for existing Connection and Close
	_lockStatus = ("extDB3" callExtension "9:LOCK_STATUS");
	//LOCK_STATUS is retarded, and instead of returning a legit array [#]
	//which is how non-system functions work in extDB3, it returns a string '[#]'
	//considering how retarded this is, I assume this may change in the future
	//so using these control variables instead of forcing in the future someone to
	//find every occurance of these checks
	One = '[1]';
	Zero = '[0]';
	
	if(_lockStatus isEqualTo One) then//Locked
	{
		systemChat format["Existing Locked Connection Detected; Disconnecting"];
		//Unlock and Disconnect
		_lockStatus = 9;
		_lockStatus = ("extDB3" callExtension "9:UNLOCK:thisisapassword");
		if(_lockStatus isEqualTo One) then //unlocked successfully
		{
			"extDB3" callExtension "9:RESET";//disconnect
			systemChat format["Existing Connection Detected; Disconnected"];
		}
		else
		{
			//Error
			systemChat format["Existing Connection Detected; Failed to Disconnect"];
		};
	}
	else
	{
		if(_lockStatus isEqualTo Zero) then//UnLocked
		{
			systemChat format["Existing Unlocked Connection Detected; Disconnecting"];
			//Disconnect
			"extDB3" callExtension "9:RESET";//disconnect
			systemChat format["Existing Connection Detected; Disconnected"];
		}
		else//Assume no connection
		{
			systemChat format["No Existing Connection Detected; Continue"];
			//Do Nothing
		};
	};
/*
	systemChat format["DB Connecting"];
	//--- Database Initialization
	//example values for failed DB connection to use to check for failure
	FailedDatabaseHandle = "extDB3" callExtension "9:ADD_DATABASE:fail";
	FailedDatabaseProtocol_1 = "extDB3" callExtension "9:ADD_DATABASE_PROTOCOL:fail:SQL:err:TEXT";
*/

	if(CTI_DATABASE_DESTINATION == 0) then {
		DatabaseHandle = "extDB3" callExtension "9:ADD_DATABASE:ofpsprod";
		DatabaseProtocol_1 = "extDB3" callExtension "9:ADD_DATABASE_PROTOCOL:ofpsprod:SQL_CUSTOM:logger:ofpsFunctions.ini";
	} else {//DB_SERVER isEqualTo "Test"
		if (CTI_DATABASE_DESTINATION == 1) then {
			DatabaseHandle = "extDB3" callExtension "9:ADD_DATABASE:ofpstest";
			DatabaseProtocol_1 = "extDB3" callExtension "9:ADD_DATABASE_PROTOCOL:ofpstest:SQL_CUSTOM:logger:ofpsFunctions.ini";
			//systemChat["DBHandle:%1 ; DBProtocol:%2", DatabaseHandle select 0, DatabaseProtocol_1 select 0];
		} else { //CTI_DATABASE_DESTINATION == 2 in this case
			DatabaseHandle = "extDB3" callExtension "9:ADD_DATABASE:local";
			DatabaseProtocol_1 = "extDB3" callExtension "9:ADD_DATABASE_PROTOCOL:local:SQL_CUSTOM:logger:ofpsFunctions.ini";
		};
		
	};
	"extDB3" callExtension "9:LOCK:thisisapassword"; //This ensures noone can run extDB3 system commands after this point
	
	_connect = call compile ("extDB3" callExtension format["0:logger:logDateTimeForGameID:%1", worldName]);
	GameID = call compile ("extDB3" callExtension format["0:logger:returnGameID"]) select 1 select 0 select 0;
	
	//grab the newest GameID, immediately after new row in gameID is generated. So this 'should' be 'this' game
	//call this anywhere else and it may grab a newer game and mess up values 
	//this ends up creating the new GameID with current date/time

	//systemChat format["Connection Tried: %1", _connect];
	
};


//--- The server is initialized, notify everyone
CTI_InitServer = true;
publicVariable "CTI_InitServer";

// Zeus admin for players
if !( isNil "ADMIN_ZEUS") then {
	//zeus settings
	ADMIN_ZEUS addCuratorAddons ["A3_Modules_F_Curator_Lightning","rkb_reischsflugscheiben"];
	//ADMIN_ZEUS removeCuratorAddons ["A3_Soft_F_MRAP_01"];
	ADMIN_ZEUS addCuratorPoints 1;
	ADMIN_ZEUS setCuratorCoef ["place", 0];
	ADMIN_ZEUS setCuratorCoef ["edit", 0];
	ADMIN_ZEUS setCuratorCoef ["delete", 0];
	ADMIN_ZEUS setCuratorCoef ["destroy", 0];
	ADMIN_ZEUS setCuratorCoef ["group", 0];
	ADMIN_ZEUS setCuratorCoef ["synchronize", 0];
	//editable objects loop
	0 spawn {
		while {!CTI_GameOver} do {
			ADMIN_ZEUS addCuratorEditableObjects [playableUnits+switchableUnits,true];
			ADMIN_ZEUS addCuratorPoints 1;
			sleep 60;
		};
	};
};
// if database tracking is enabled, we start a loopy loop
if (CTI_DATABASE_TRACKING) then
{
	_connectStatus = call compile ("extDB3" callExtension format["0:logger:logDebugLog:Logged Game Creation UID:%1", GameID]);
	if !( isNil "_connectStatus") then { 
		if ((_connectStatus select 0) isEqualTo 1) then {
			systemChat format["Connection Success"];
			0 spawn CTI_SE_DatabaseLoop;
		}
		else
		{
			systemChat format["Connection Failed"];
			CTI_DATABASE_TRACKING = false;//if databasehandle isn't init, cancel database tracking
		};
	};
};

//--- CRAM Initializations
//call compile preprocessFile "Server\Functions\Externals\HandleCRAM.sqf";
//[east] spawn FNC_CRAM_Monitor;
//[west] spawn FNC_CRAM_Monitor;
//[resistance] spawn FNC_CRAM_Monitor;


missionNamespace setVariable ["CTI_SUSPENDED_TEAMS", []];



/*0 spawn {
	// Give HCs some init time
	sleep 30;
	
	_hcs = missionNamespace getVariable "CTI_HEADLESS_CLIENTS";
	
	// Run on server or HC
	if ( !isNil '_hcs' && {count _hcs > 0} ) then {
		_hc = (_hcs select 0) select 0;
		{
			FNC_HandleCRAM = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\HandleCRAM.sqf";
			[east] spawn FNC_HandleCRAM;
			[west] spawn FNC_HandleCRAM;
			[resistance] spawn FNC_HandleCRAM;
		} remoteExec ["bis_fnc_call", _hc];
	} else {
		FNC_HandleCRAM = compileFinal preprocessFileLineNumbers "Server\Functions\Externals\HandleCRAM.sqf";
		[east] spawn FNC_HandleCRAM;
		[west] spawn FNC_HandleCRAM;
		[resistance] spawn FNC_HandleCRAM;
	};
};*/

execVM "Server\Functions\Server_VehicleLoop.sqf";


// As far as we know; the dead AI need to be transferred back to the server
// so the remains collector will remove them. 
[] spawn 
{ 
    while {!CTI_GameOver} do 
    {
        { _x remoteExecCall ["deleteVehicle",_x]; } forEach allDeadMen;
        sleep 60;
    };
}; 